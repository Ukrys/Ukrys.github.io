---
layout:     post
title:      Web前端-考点补充
subtitle:   Web前端考点补充
date:       2023-04-17
author:     ukrys
header-img: img/post-bg-js-version.jpg
catalog: 	 true
tags:
    - Web
    - Exam
---

# Web 考点补充

【**TIPS: 此文档为笔记未整理但考点覆盖的内容**】

## Web发展历程

-	Web1.0
  -	Web of documents
  -	可读
-	Web2.0
  -	Web of data(semantics)
  -	可读+可写
-	Web3.0
  -	Web of persons
  -	可读+可写+可拥有

## Web3.0 特征

语义化、3D、人工智能、去中心化

## 块级、行内以及行内块标签

### 块级标签
块级标签：作为容器，可嵌套其他块级或行内标签元素（不管标签的内容有多少，都要占据一行）:div，段落，标题，有序和无序列表，自列表标签选项，定义列表，头部，尾部，导航，表单，表格等标签

1. div（区块标签：大）
2. p（p标签不可以嵌套其他块级标签）
3. h1~h6
4. ol
5. ul
6. li
7. dl
8. dt
9. dd
10. header
11. footer
12. nav
13. form
14. table

### 行内标签
行内块标签：sapn、 img、a、label、code、input、abbr、em、b、big、cite、i、q、textarea、select、small、sub、sup，strong、u、li、ins、del、dfn、kbd、var

1. span（区块标签：小）
2. a
3. strong
4. b
5. ins
6. del
7. i
8. br

**行内标签应该注意的：**

- 没有宽高，内容多大就多大（行内标签不要嵌套块级标签，a除外）
- 行内标签设置宽高无效，可以对行高line-height进行设置
- 可以设置外边距margin和内边距padding，但只对左右边距有效果，上下无效

- 主要有span，链接，强调，加粗，下划线，删除线，斜体,换行标签等

### 行内块标签
行内块标签：特殊的行内标签（可设置高宽）图片，输入框标签。

1. input

2. img

- 三种属性标签之间的切换方法：利用display属性
  - 行内标签转块级标签：display:block;
  - 块级转行内：display:inline;
  - 块级转行内块：display:inline-block。



## HTML5

### 应用

- 本地数据存储
- 访问本地⽂件
- 本地 SQL 数据
- 缓存引用
- Javascript ⼯作者
- XHTMLHttpRequest 2

### 优势

- 跨浏览器兼容性 
- ⼤道⾄简 
- 语义化 
- 可⽤性和⽤户体验的改进 
- ⽆插件范式 
- 安全 
- ⼤量⽤于移动应⽤和游戏 
- 在⽹站抓取和索引⽅⾯，HTML5 对 SEO 友好

### 语义化

- 根据结构化的内容选择合适的标签
  - 有利于SEO
  - 开发维护体验好
  - 用户体验更好
  - 更好的可访问性，方便任何设备对代码进行解析

| [![pSjzg9s.png](https://s1.ax1x.com/2023/02/22/pSjzg9s.png)](https://imgse.com/i/pSjzg9s) | [![pSjzRcq.png](https://s1.ax1x.com/2023/02/22/pSjzRcq.png)](https://imgse.com/i/pSjzRcq) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [![pSjz5HU.png](https://s1.ax1x.com/2023/02/22/pSjz5HU.png)](https://imgse.com/i/pSjz5HU) | [![pSjzoEF.png](https://s1.ax1x.com/2023/02/22/pSjzoEF.png)](https://imgse.com/i/pSjzoEF) |

### 新元素和新功能

**新功能特性**

- 新元素 

- 新属性 

- 完全⽀持 CSS3 

- Video 和 Audio 

- 2D/3D 制图 

  | [![pSvSU54.png](https://s1.ax1x.com/2023/02/22/pSvSU54.png)](https://imgse.com/i/pSvSU54) | [![pSvS2Ie.png](https://s1.ax1x.com/2023/02/22/pSvS2Ie.png)](https://imgse.com/i/pSvS2Ie) |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |

  

- web存储 

  - 早期本地存储使用的是cookie，但是web存储更加的安全与快速
  - 客户端存储数据的两个对象为：
    - localStorage -  用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。
    - sessionStorage - 用于临时保存同⼀窗⼝(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。

- 离线浏览 

  | [![pSvSosP.png](https://s1.ax1x.com/2023/02/22/pSvSosP.png)](https://imgse.com/i/pSvSosP) | [![pSvSbdS.png](https://s1.ax1x.com/2023/02/22/pSvSbdS.png)](https://imgse.com/i/pSvSbdS) |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |

  

- HTML5 Web SQL 数据库 

  - Web SQL 数据库 API 并不是 HTML5 规范的⼀部 分，但是它是⼀个独⽴的规范，引⼊了⼀组使⽤ SQL 操作客户端数据库的 APIs。
  - 规范中定义的三个核⼼⽅法： 
    - openDatabase：这个⽅法使⽤现有的数据库或者新建的数据库创建⼀个数据库对象。 
    - transaction：这个⽅法让我们能够控制⼀个事务， 以及基于这种情况执⾏提交或者回滚。 
    - executeSql：这个⽅法⽤于执⾏实际的 SQL 查询。

- HTML5 Web Workers 

  - 当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。
  - web worker 是运⾏在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。

- HTML5 WebSocket

  ![image-20230222143755265](C:\Users\94327\AppData\Roaming\Typora\typora-user-images\image-20230222143755265.png)

**新元素**

[![pSjzxHO.png](https://s1.ax1x.com/2023/02/22/pSjzxHO.png)](https://imgse.com/i/pSjzxHO)



## CSS

### 基本概念

- Cascading Style Sheets，层叠样式表
- CSS 用于设计风格和布局
  - 比如，可以使用 CSS 来更改内容的字体、颜色、大小、间距，将内容分为多列，或者添加动画及其他的装饰效果。

### 选择器

- id选择器

  - id选择器可以为标有特定 id 的 HTML 元素指定特定的样式。

    - HTML元素以id属性来设置id选择器, CSS 中 id 选择器以 "#" 来定义。

    - 下⾯的样式规则将应用于有属性id=“para1"的元素: 

      ```css
      #para1 {text-align:center;color:red;}
      ```

- class选择器

  -  class 选择器⽤于描述⼀组元素的样式，class 选择器有 别于id选择器，class可以在多个元素中使⽤

  - class 选择器在 HTML 中以 class 属性表示, 在 CSS 中，类选择器以⼀个点 . 号显示

  - 在以下的例⼦中，所有拥有 center 类的 HTML 元素均 为居中

    ```css
    .center {text-align:center;}
    ```

- 标签选择器

  ```css
  p
  {
  color:red;
  text-align:center;
  } 
  ```

- 属性选择器 

  ```css
  [title]
  {
   color:blue;
  }
  <h1 title="Hello world">Hello world</h1>
  ```

- 伪类选择器 

  - CSS伪类是⽤来添加⼀些选择器的特殊效果。

    ```css
    selector:pseudo-class {property:value;}
    selector.class:pseudo-class {property:value;}
    
    a:link {color:#000000;} /* 未访问链接*/
    a:visited {color:#00FF00;} /* 已访问链接 */
    a:hover {color:#FF00FF;} /* ⿏标移动到链接上 */
    a:active {color:#0000FF;} /* ⿏标点击时 */
    ```

- 伪元素选择器 

  ```css
  selector:pseudo-element {property:value;}
  selector.class:pseudo-element {property:value;}
  
  p:first-line
  {
  color:#ff0000;
  font-variant:small-caps;
  }
  /* 使用"FIRST-LINE"伪元素向文本的首行设置特殊样式 */
  ```

- 组合选择器

  - 后代选择器(以` `分隔) 

    [![pSvCQ8H.png](https://s1.ax1x.com/2023/02/22/pSvCQ8H.png)](https://imgse.com/i/pSvCQ8H)

  - 子元素选择器(以`>`分隔）

    [![pSvC1xA.png](https://s1.ax1x.com/2023/02/22/pSvC1xA.png)](https://imgse.com/i/pSvC1xA)

  - 相邻兄弟选择器（以`+`分隔）

    ![image-20230222145116079](C:\Users\94327\AppData\Roaming\Typora\typora-user-images\image-20230222145116079.png)

  - 普通兄弟选择器（以`~`分隔）

    [![pSvC8KI.png](https://s1.ax1x.com/2023/02/22/pSvC8KI.png)](https://imgse.com/i/pSvC8KI)

**注释**

- `/* ..... */`

### 层叠排序

⽤来解决样式说明冲突的整个排序过程称为层叠。

- 浏览器缺省样式 

- 内联样式

  - 内联⽅式指的是直接在 HTML 标签中的 style 属性中添 加 CSS。

    ```html
    <p style=“color: red;”> This is a simple paragraph and the
    inline style makes it red.</p>
    ```

- 嵌⼊样式表

  - 嵌⼊⽅式指的是在 HTML 头部中的 `<style>`\> 标签下书写 CSS 代码。

    ```html
    <head>
    	<title>my page</title>
    	<style type=“text/css”>
     		p{color:red}
        </style>
    </head>
    <body>
    	<p>this is a simple paragraph</p>
    </body>
    ```

- 外部样式表

  - 链接⽅式：指的是使⽤ HTML 头部的  标签引⼊外部的 CSS ⽂件。

    ```html
    <head>
     <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    ```

  - 导⼊⽅式：指的是使⽤ CSS 规则引⼊外部 CSS ⽂件。

    ```css
    <style>
     @import url(style.css);
    </style>
    ```

  - 比较：
    - link 属于 HTML，通过标签中的 href 属性来引⼊外部⽂件，⽽ @import 属于 CSS，所以 导⼊语句应写在 CSS 中，要注意的是导⼊语句应写在样式表的开头，否则⽆法正确导⼊外部⽂件；
    - @import 是 CSS2.1 才出现的概念，所以如果浏览器版本较低，⽆法正确导⼊外部样式⽂件；
    - 当 HTML ⽂件被加载时，link 引用的文件会同时被加载，而@import 引用的⽂件则会等全部页面下载完毕再被加载；
    - 使用DOM控制样式时的差别

**继承**

- 当元素的一个继承属性(inherited property)没有指定时，则取父元素的同属性的计算值
- 不是所有的属性都会被继承

**层叠顺序**

- 层叠算法决定如何找出要应⽤到每个⽂档元素的每个属性上的值。

  - 首先过滤来自不同源的全部规则，并保留要应用到指定元素上的那些规则。这意味着这些规则的选择器匹配指定元素，同时也是⼀个 合适的 @规则（at-rule）的⼀部分。
  - 其次，它依据重要性对这些规则进⾏排序。即是指，规则后面是否跟随着!important 以及规则的来源。层叠是按升序排列的，这意 味着来着⽤户⾃定义样式表的 !important 值比用户代理样式表的普通值优先级⾼：
  - 假如层叠顺序相等，则使用哪个值取决于优先级。

- 根据来源和重要程度排序

  > ⽤户代理：浏览器会有⼀个基本的样式表来给任何⽹⻚设置默认样式。这些样式统称⽤户代理样式。⼀些浏览器通过使⽤真正的样式 表，⽽其他则通过代码模拟，但⽆论是哪种情形都应是不可被检测 的。⽽且部分浏览器允许⽤户修改⽤户代理样式。尽管 HTML 标准对 ⽤户代理样式做了诸多限制，浏览器仍⼤有可为，具体表现在不同浏 览器间会存在重⼤的差异。为了减轻开发成本以及降低样式表运⾏所 需的基本环境，⽹⻚开发者通常会使⽤⼀个 CSS reset 样式表，强制 将常⻅的属性值转为确定状态。 
  >
  > ⽹⻚作者，可以定义⽂档的样式，这是最常⻅的样式表。⼤多数情况下此类型样式表会定义多个，它们构成⽹站的视觉和体验，即主题。
  >
  > ⽤户，作为浏览器的⽤户，可以使⽤⾃定义样式表定制使⽤体验。

  - 相互冲突的声明将按以下顺序应⽤，后⼀种声明将覆盖前⼀种声明：

    - 用户代理样式表中的声明（例如，浏览器的默认样式，在没有设置其他样式时使用）。
    -  用户样式表中的常规声明（由用户设置的自定义样式）。
    - 作者样式表中的常规声明（这些是我们 web 开发人员设置的样式）。
    - 作者样式表中的 !important 声明
    - 用户样式表中的 !important 声明 
    - 用户代理样式表中的 !important 声明

    ```html
    <div class="foo" style="color: red;">What color am I?</div>
    ```

    ```css
    .foo[style*="color: red"] {
     	color: firebrick !important;
    }
    ```

- 优先级 (specificity)
  - 优先级就是分配给指定的 CSS 声明的⼀个权重，它由匹配的选择器中的每⼀种选择器类型的数值决定。
  - ⽽当优先级与多个 CSS 声明中任意⼀个声明的优先级相等的时候，CSS 中最后的那个声明将会被应⽤到元素上。
  - 当同⼀个元素有多个声明的时候，优先级才会有意义
  - 给元素添加的内联样式 (例如，style="fontweight:bold") 总会覆盖外部样式表的任何样式，因此 可看作是具有最⾼的优先级。
  - 优先级的计算
    - 如果声明来⾃⼀个'style'属性而不是⼀条选择器样式规则，算1，否则就是0 (= a)（HTML中，⼀个元素的 "style"属性值是样式表规则，这些属性没有选择器，所 以a=1，b=0，c=0，d=0）
    - 计算选择器中ID属性的数量 (= b) 
    - 计算选择器中其它属性和伪类的数量 (= c) 
    - 计算选择器中元素名和伪元素的数量 (= d)
    - 4个数连起来a-b-c-d表示优先级[![pSvFyqI.png](https://s1.ax1x.com/2023/02/22/pSvFyqI.png)](https://imgse.com/i/pSvFyqI)



## CSS3

### 新特性

很多：圆⻆效果、图形化边界、块阴影与⽂字阴影、使⽤RGBA实现透明效果、渐变效果、使⽤ @Font-Face实现定制字体、多背景图、⽂字或图像的变形处理（旋转、缩放、倾斜、移动）、多栏布局、媒体查询等。

### CSS Sprites

图像精灵是单个图像中包含的图像集合。

优点： 包含许多图像的⽹⻚可能需要很⻓时间才能加载，同时会⽣成多个 服务器请求。 使⽤图像精灵将减少服务器请求的数量并节约带宽。 解决了⽹⻚设计师在图⽚命名上的困扰 更换⻛格⽅便

缺点： 维护麻烦 图片合并费时费⼒



## 前端鉴权

### HTTP基本鉴权

 在 HTTP 中，基本认证方案（Basic Access Authentication)是允许客户端（通常指的就是网页浏览器）在请求时，通过用户提供用户名和密码的方式，实现对用户身份的验证。

**流程**

1. 客户端：向服务器请求一个受限的列表数据或资源
2. 服务器：向客户端返回 401状态码，附带一个认证域要求身份认证
3. 客户端：讲用户名及密码以Base64加密方式发送给服务器
4. 服务器：校验信息，发送资源。

**优点**

​	简单，基本所有流行的浏览器都支持

**缺点**

​	不安全；无法主动注销

### Session-Cookie 鉴权

Session-Cookie认证是利用服务端的Session（会话）和浏览器（客户端）的 Cookie 来实现的前后端通信认证模式。

**流程**

1. 客户端：向服务器发送登录信息用户名/密码来请求登录校验；

2. 服务器：验证登录的信息，验证通过后自动创建 Session（将 Session 保存在内存中，也可以保存在 Redis 中），然后给这个 Session 生成一个唯一的标识字符串会话身份凭证session_id(通常称为sid)，并在响应头Set-Cookie中设置这个唯一标识符；

   注：可以使用签名对sid进行加密处理，服务端会根据对应的secret密钥进行解密 （非必须步骤）

3. 客户端：收到服务器的响应后会解析响应头，并自动将sid保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息；

4. 服务器：接收客户端请求时会去解析请求头 Cookie 中的sid，然后根据这个sid去找服务端保存的该客户端的sid，然后判断该请求是否合法；

**优点**

1. Cookie简单易用
2. Session 数据存储在服务端，相较于     JWT 方便进行管理，也就是当用户登录和主动注销，只需要添加删除对应的     Session 就可以了，方便管理
3. 只需要后端操作即可，前端可以无感等进行操作；

**缺点**

1. 依赖 Cookie，一旦用户在浏览器端禁用     Cookie，那么就 GG 思密达了；
2. 非常不安全，Cookie 将数据暴露在浏览器中，增加了数据被盗的风险（容易被     CSRF 等攻击）；
3. Session 存储在服务端，增大了服务端的开销，用户量大的时候会大大降低服务器性能；
4. 对移动端的支持性不友好；

### Token鉴权

Token是一个令牌，客户端访问服务器时，验证通过后服务端会为其签发一张令牌，之后，客户端就可以携带令牌访问服务器，服务端只需要验证令牌的有效性即可。

**流程**

1. 客户端：输入用户名和密码请求登录校验
2. 服务器：收到请求，去验证用户名与密码；验证成功后，服务端会签发一个Token并把这个Token发送给客户端
3. 客户端：收到Token以后需要把它存储起来，web端一般会放在localStorage或Cookie中，移动端原生APP一般存储在本地缓存中
4. 客户端发送请求：向服务端请求API资源的时候，将Token通过HTTP请求头 Authorization字段或其他方式发送给服务端
5. 服务器：收到请求，然后去验证客户端请求里面带着的Token，如果验证成功，就向客户端返回请求的数据，否则拒绝返还401

**优点**

1. 服务端无状态化，可扩展性好
2. 支持APP移动端设备
3. 安全性好
4. 支持跨程序调用

**缺点**

1. 需要前后端配合
2. 挤占更多带宽
3. 对Token加解密等操作更耗性能
4. Token有效期短

### JWT（JSON Web Token）鉴权

JWT 是 Auth0 提出的通过 对 JSON 进⾏加密签名来实现授权验证的⽅案（流程类似token）

**流程**

1. 客户端：输入用户名和密码请求登录校验
2. 服务器：将用户信息组成JSON对象，然后对这个对象进行某种方式的加密，返回给客户端
3. 客户端：下次请求时带上这个Token
4. 服务器：收到请求时校验token合法性，其实也就是在校验请求的合法性

**优点**

1. 信息不保存在服务端，扩展性好
2. JWT中的Payload负载可以存储常用信息，用于信息交换，有效地使用 JWT，可以降低服务端查询数据库的次数

**缺点**

1. 加密问题：JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
2. **到期问题：**由于服务器不保存 Session 状态，因此无法在使用过程中废止某个     Token，或者更改 Token 的权限。也就是说，一旦     JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。

### 单点登录（Single Sign On）

在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。

**流程**

同域：

1. 客户端：用户访问某个子系统时（例如tieba.baidu.com），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录；
2. 服务端：登录认证后，服务端把登录用户的信息存储于 Session 中，并且附加在响应头的Set-Cookie字段中，设置 Cookie 的 Domain 为.baidu.com；
3. 客户端：再次发送请求时，携带主域名 Domain 下的 Cookie 给服务器，此时服务端就可以通过该 Cookie 来验证登录状态了；

跨域：

1. 客户端：开始访问系统 A；
2. 系统A：发现用户未登录，重定向至 CAS 认证服务（sso.com），同时 URL 地址参数携带登录成功后回跳到系统 A 的页面链接（https://sso.com/login?redirectURL=https%3A%2F%2Fwww.taobao.com%EF%BC%89%EF%BC%9B）
3. CAS认证服务：发现请求 Cookie 中没有携带登录的票据凭证（TGC），所以 CAS 认证服务判定用户处于未登录状态，重定向用户页面至 CAS 的登录界面，用户在 CAS 的登录页面上进行登录操作。
4. 客户端：输入用户名密码进行 CAS 系统认证；
5. CAS认证服务：校验用户信息，并且生成 TGC放入自己的 Session 中，同时以 Set-Cookie 形式写入 Domain 为sso.com的域下 ；同时生成一个授权令牌 ST (Service Ticket)，然后重定向至系统 A 的地址，重定向的地址中包含生成的 ST（重定向地址：https://www.taobao.com?token=ST-345678%EF%BC%89）
6. 系统A：拿着 ST 向 CAS 认证服务发送请求，CAS 认证服务验证票据 (ST) 的有效性。验证成功后，系统 A 知道用户已经在 CAS 登录了（其中的 ST 可以保存到 Cookie 或者本地中），系统 A 服务器使用该票据 (ST) 创建与用户的会话，称为局部会话，返回受保护资源；到这里客户端就可以跟系统 A 愉快的交往啦 ~
7. 客户端：开始访问系统 B；

8. 系统B：发现用户未登录，重定向至 SSO 认证服务，并将自己的地址作为参数传递，并附上在 sso.com 域下的 cookie 值是第五步生成的 TGC；

9. CAS认证服务：CAS 认证服务中心发现用户已登录，跳转回系统 B 的地址，并附上票据 (ST) ;

10. 系统B：拿到票据 (ST)，去 CAS 认证服务验证票据 (ST) 的有效性。验证成功后，客户端也可以跟系统 B 交往了 ~

### OAuth 2.0

OAuth是一个开放标准，允许用户授权第三方网站 (CSDN、思否等) 访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站；

### 联合登录和信任登录

联合登录 指同时包含多种凭证校验的登录服务，同时，也可以 理解为使⽤第三⽅凭证进⾏校验的登录服务。

信任登录 是指所有不需要⽤户主动参与的登录，例如建⽴在私 有设备与⽤户之间的绑定关系，凭证就是私有设备的信息，此 时不需要⽤户再提供额外的凭证。信任登录⼜指⽤第三⽅⽐较 成熟的⽤户库来校验凭证，并登录当前访问的⽹站。

### 唯一登录

唯⼀登录，指的是禁⽌多⼈同时登录同⼀账号，后者的登录⾏ 为，会导致前者掉线。

### 扫码登陆

扫码登录通常⻅于移动端 APP 中，很多 PC 端的⽹站都提供了 扫码登录的功能，⽆需在⽹⻚上输⼊任何账号和密码，只需要 让移动端 APP (如微信、淘宝、QQ等等) 中已登录⽤户主动扫 描 ⼆维码 ，再确认登录，以使 PC 端的同款应⽤得以快速登录 的⽅式就是 扫码登录 。

### 一键登录

短信验证码的作⽤就是证明当前操作⻚⾯的⽤户与输⼊⼿机号 的⽤户为相同的⼈，那么实际上只要我们能够获取到当前⼿机 使⽤的⼿机卡号，直接使⽤这个号码进⾏登录，不需要额外的 操作，这就是⼀键登录。



## 登陆注册

### 验证码

又被称作全自动区分计算机和人类的图灵测试（Completely Automated Public Turing test to tell Computers and Humans Apart，简称CAPTCHA），俗称验证码，是一种区分用户是计算机和人的公共全自动程序。验证码的主要目的是强制人机交互来抵御机器自动化攻击，为了确保服务器系统的稳定和用户信息的安全，越来越多的网站采用了验证码技术。

### 密码

常用的加密方式

| **算法** | **特点**       | **有效破解方式** | **破解难度** | **其它**           |
| -------- | -------------- | ---------------- | ------------ | ------------------ |
| 对称加密 | 可以解密出明文 | 获取密钥         | 中           | 需要确保密钥不泄露 |
| 单向HASH | 不可解密       | 碰撞、彩虹表     | 中           |                    |
| 特殊HASH | 不可解密       | 碰撞、彩虹表     | 中           | 需要确保“盐”不泄露 |
| Pbkdf2   | 不可解密       | 无               | 难           | 需要设定合理的参数 |
| BCrypt   | 不可解密       | 无               | 难           | 需要设定合理的参数 |
| SCrypt   | 不可解密       | 无               | 难           | 需要设定合理的参数 |
| Argon2   | 不可解密       | 无               | 难+          |                    |

## 前端主题切换

### link标签动态引入

做法就是提前准备好几套`CSS`主题样式文件，在需要的时候，创建`link`标签动态加载到`head`标签中，或者是动态改变`link`标签的`href`属性。

**优点**

- 实现了按需加载，提高了首屏加载时的性能

**缺点**

- 动态加载样式文件，如果文件过大网络情况不佳的情况下可能会有加载延迟，导致样式切换不流畅
- 如果主题样式表内定义不当，会有优先级问题
- 各个主题样式是写死的，后续针对某一主题样式表修改或者新增主题也很麻烦

### 提前引入所有主题样式，做类名切换

为了解决反复加载样式文件问题提前将样式全部引入，在需要切换主题的时候将指定的根元素类名更换，相当于直接做了样式覆盖，在该类名下的各个样式就统一地更换了。

**优点**

- 不用重新加载样式文件，在样式切换时不会有卡顿

**缺点**

- 首屏加载时会牺牲一些时间加载样式资源
- 如果主题样式表内定义不当，也会有优先级问题
- 各个主题样式是写死的，后续针对某一主题样式表修改或者新增主题也很麻烦

### CSS变量+类名切换

大体思路跟方案2相似，依然是提前将样式文件载入，切换时将指定的根元素类名更换。不过这里相对灵活的是，默认在根作用域下定义好CSS变量，只需要在不同的主题下更改CSS变量对应的取值即可。

**优点**

- 不用重新加载样式文件，在样式切换时不会有卡顿
- 在需要切换主题的地方利用var()绑定变量即可，不存在优先级问题
- 新增或修改主题方便灵活，仅需新增或修改CSS变量即可，在var()绑定样式变量的地方就会自动更换

**缺点**

- IE兼容性（忽略不计）
- 首屏加载时会牺牲一些时间加载样式资源