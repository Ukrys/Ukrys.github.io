---
layout:     post
title:      Web前端-Lec13 前端性能优化
subtitle:   Web前端笔记
date:       2023-04-17
author:     ukrys
header-img: img/post-bg-js-version.jpg
catalog: 	 true
tags:
    - Web前端
    - Notes
---

## Lecture13 前端性能优化

### 13.1 Web 性能优化 web performance optimization(WPO)

  网站速度对你的SEO工作很重要，因为更快的网站是：更容易爬取，更容易访问，更有利于排名（尽管这是边际的）最重要的是，更有可能留住访客。

> SEO（Search Engine Optimization）：汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益。很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。

- 网站越快，用户的黏性越高；参与度
- 网站越快，用户忠诚度更高；留存率
- 网站越快，用户转化率越高

####  13.1.1 延迟与带宽

- 延迟
  - 分组从信息源发送到目的地所需的时间
- 带宽
  - 逻辑或物理通信路径最大的吞吐量

![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115095959.png)

- 延迟的构成要素

  - 传播延迟：消息从发送端到接收端需要的时间，是信号传播距离和速度的函数

  - 传输延迟：把消息中的所有比特转移到链路中需要的时间,是消息长度和链路速率的函数

  - 处理延迟：处理分组首部、检查位错误及确定分组⽬标所需的时间

  - 排队延迟：到来的分组排队等待处理的时间

#### 13.1.2 Web性能要点

- 延迟和带宽对Web性能的影响
- 传输协议(TCP)对HTTP的限制
- HTTP协议自身的功能和缺陷
- Web应用的发展趋势及性能需求
- 浏览器局限性和优化思路



- 不同层之间总是相互依赖，但优化方式却有很多可能性。任何优化建议和最佳做法都不是一成不变的，涉及的每个要素都是动态发展的：
  - 浏览器越来越快
  - 用户上网条件不断改善
  - Web应用的功能和复杂度也与日俱进

### 13.2 浏览器页面渲染机制

#### 13.2.1 导航

- DNS 查询
- TCP 握手
  - ⼀旦获取到服务器 IP 地址，浏览器就会通过 TCP“三次握手” (en-US)与服 务器建立连接。TCP 的“三次握手”技术经常被称为“SYN-SYN-ACK”。
- TLS 协商
  - 为了在 HTTPS 上建立安全连接，另⼀种握手是必须的。更确切的说是 TLS 协商，它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要三次往返服务器。

![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115102011.png)

#### 13.2.2 响应

- 初始请求的响应包含所接收数据的第⼀个字节。Time to First Byte（TTFB）是用户通过点击链接进行请求与收到第⼀个 HTML 数据包之间的时间。
- 初始页面加载的 14KB 规则，第⼀个内容分块通常是 14KB 的数据。
- TCP 慢启动 / 14KB 规则
  - 第⼀个响应数据包是 14KB 大小的。这是慢启动的⼀部分，慢启动是⼀种均衡网络连接速度的算法。慢启动逐渐增加发送数据的数量直到达到网络的最大带宽。
  - TCP 慢启动中，在收到初始包之后，服务器会将下⼀个数据包的大小加倍到大约 28KB。后续的数据包依次是前⼀个包大小的⼆倍直到达到预定的阈值，或者遇到拥塞。

![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115102326.png)

#### 13.2.3 解析

- ⼀旦浏览器收到数据的第⼀块，它就可以开始解析收到的信息。“解析” 是浏览器将通过网络接收的数据转换为 DOM 和 CSSOM 的步骤，通过渲染器把 DOM 和 CSSOM 在屏幕上绘制成页面。

  ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115102923.png)

#### 13.2.4 构建 DOM 树

- 第⼀步是处理 HTML 标记并构造 DOM 树。HTML 解析涉及到 tokenization 和树的构造。
- 当解析器发现非阻塞资源，例如⼀张图片，浏览器会请求这些资源并且继续解析。当遇到 ⼀个 CSS 文件时，解析也可以继续进行，但是对于 `<script>`标签（特别是没有 async 或者 defer 属性的）会阻塞渲染并停止 HTML 的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。

#### 13.2.5 预加载扫描器

- 浏览器构建 DOM 树时，这个过程占用了主线程。当这种情况发生时， 预加载扫描仪将解析可用的内容并请求高优先级资源，如 CSS、 JavaScript 和 web 字体。多亏了预加载扫描器，我们不必等到解析器找到对外部资源的引用来请求它。它将在后台检索资源，以便在主 HTML 解析器到达请求的资源时，它们可能已经在运行，或者已经被下载。预加载扫描仪提供的优化减少了阻塞。

  ```html
  <link rel="stylesheet" src="styles.css"/>
  <script src="myscript.js" async></script>
  <img src="myimage.jpg" alt="image description"/>
  <script src="anotherscript.js" async></script>
  ```

#### 13.2.6 构建 CSSOM 树

- CSS 对象模型，简称 CSSOM
- 第二步是处理 CSS 并构建 CSSOM 树。CSS 对象模型和 DOM 是相似的。DOM 和 CSSOM 是两棵树。它们是独立的数据结构。浏览器将 CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和兄弟关系的节点树。

#### 13.2.7 其他过程

- Javascript 编译
  - 当 CSS 被解析并创建 CSSOM 时，其他资源，包括 JavaScript 文件正在下载（借助预加载扫描器）。JavaScript 被解释、编译、解析和执行。 脚本被解析为抽象语法树。⼀些浏览器引擎使用抽象语法树并将其传递到解释器中，输出在主线程上执行的字节码。这就是所谓的 JavaScript 编译。
- 构建辅助功能树
  - 浏览器还构建辅助设备用于分析和解释内容的辅助功能（accessibility） 树。无障碍对象模型（AOM）类似于 DOM 的语义版本。当 DOM 更新时，浏览器会更新辅助功能树。辅助技术本身无法修改无障碍树。
  - 在构建 AOM 之前，屏幕阅读器（screen readers (en-US)）无法访问内容。

#### 13.2.8 渲染

- 渲染步骤包括样式、布局、绘制，在某些情况下还包括合成。在解析步 骤中创建的 CSSOM 树和 DOM 树组合成⼀个 Render 树，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。在某些情况下，可以将内容提升到它们自己的层并进行合成，通过在 GPU 而不是 CPU 上绘制屏幕的⼀部分来提⾼性能，从而释放主线程。

#### 13.2.9 Style

- 第三步是将 DOM 和 CSSOM 组合成⼀个 Render 树，计算样式树或渲染树从 DOM 树的根开始构建，遍历每个可见节点。
- 像`<head>`和它的子节点以及任何具有 `display: none` 样式的结点，例如 `script { display: none; }`（在 user agent stylesheets 可以看到这个样式）这些标签将不会显示，也就是它们不会出现在 Render 树上。具有 `visibility: hidden`的节点会出现在 Render 树上，因为它们会占用空间。由于我们没有给出任何指令来覆盖用户代理的默认值，因此上面代码示例中的 script 节点将不会包含在 Render 树中。
- 每个可见节点都应用了其 CSSOM 规则。Render 树保存所有具有内容和计算样式的可见节点——将所有相关样式匹配到 DOM 树中的每个可见节点，并根据 CSS 级联确定每个节点的计算样式。

#### 13.2.10 布局

- 第四步是在渲染树上运行布局以计算每个节点的几何体。布局（Layout）是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。回流（reflow）是对页面的任何部分或整个文档的任何后续大小和位置的确定。
  - 第一次确定节点的大小和位置称为布局
  - 随后对节点大小和位置的重新计算称为回流
- 构建渲染树后，开始布局。渲染树标识显示哪些节点（即使不可见）及其计算样式，但不标识每个节点的尺寸或位置。为了确定每个对象的确切大小和位置，浏览器从渲染树的根开始遍历它。

#### 13.2.11 绘制

- 最后⼀步是将各个节点绘制到屏幕上，第⼀次出现的节点称为 first meaningful paint (en-US)。在绘制或光栅化阶段，浏览器将在布局阶段计算 的每个框转换为屏幕上的实际像素。
- 为了确保平滑滚动和动画，占据主线程的所有内容，包括计算样式，以及回流和绘制，必须让浏览器在 16.67 毫秒内完成。
- 为了确保重绘的速度比初始绘制的速度更快，屏幕上的绘图通常被分解成数层。如果发生这种情况，则需要进行合成。
- 绘制可以将布局树中的元素分解为多个层。将内容提升到 GPU 上的层（而不是 CPU 上的主线程）可以提高绘制和重新绘制性能。
- 分层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的⼀部分过度使用。
- 当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。

#### 13.2.12 交互

- ⼀旦主线程绘制页面完成，你会认为我们已经“准备好了”，但事实并非如此。如果加载包含 JavaScript（并且延迟到 onload 事件激发后执行），则主线程可能很忙，无法用于滚动、触摸和其他交互。
- Time to Interactive (en-US)（TTI）是测量从第⼀个请求导致 DNS 查询和 SSL 连接到页面可交互时所用的时间——可交互是 First Contentful Paint (en-US) 之后的时间点，页面在 50ms 内响应用户的交互。如果主线程正在解析、编译和执行JavaScript，则它不可用，因此无法及时（小于 50ms）响应用户交互。
- 每当浏览器遇到脚本标签时，DOM 构造就会暂停！整个 DOM 构建过程都将停止，直到脚本执行完成。
  - JavaScript 可以同时修改 DOM 和 CSSOM
- 在默认情况下，每个脚本都是⼀个解析器阻断器！
  - 例外，async

#### 13.2.13 关键渲染路径

- 周密的关键渲染路径（CRP）优化策略使浏览器能够通过确定优先加载的资源以及资源加载的顺序来尽可能快地加载页面。
- 优化CRP
  - 提升页面加载速度需要通过被加载资源的优先级、控制它们加载的顺序和减小这些资源的体积。性能提示包含
    - 通过异步、延迟加载或者消除非关键资源来减少关键资源的请求数量，
    - 优化必须的请求数量和每个请求的文件体积，
    - 通过区分关键资源的优先级来优化被加载关键资源的顺序，来缩短关键路径长度。

![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115112242.png)

### 13.3 现代Web应用程序剖析

2022年末，一个普通的Web应用由下列内容构成。

- 71个请求，发送到15个主机，总下载量2284KB
  - HTML: 2个请求，29 KB 
  - 图片: 22个请求，1001 KB 
  - JavaScript: 22个请求， 515 KB
  - CSS:7 个请求，75 KB
  - Font:4个请求，144 KB
  - 其他资源:3个请求，1 KB
  - 视频：3个请求，3472 KB

#### 13.3.1 时间和用户感知

| Delay       | User perception                           |
| ----------- | ----------------------------------------- |
| 0-100 ms    | Instant很快                               |
| 100-300 ms  | Small perceptible delay 有一点点慢        |
| 300-1000 ms | Machine is working 机器在工作呢           |
| 1000+ ms    | Likely mental context switch 先干点别的吧 |
| 10000+ ms   | Task is abandoned  不能用了               |

#### 13.3.2 资源瀑布图

| ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115112738.png) |
| ------------------------------------------------------------ |
| ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115112802.png) |

#### 13.3.3 性能要素：计算、渲染、网络

- web程序的执行主要包括三个任务：获取资源，页面布局和渲染，以及 JavaScript 执行。

  - 更多带宽并不重要
  - 延迟是性能瓶颈

  ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115112957.png)

#### 13.3.4 Benchmark工具

- Apache Bench：apache⾃带的⼀款功能强大的测试工具。
- Siege：⼀款开源的压力测试⼯具，可以根据配置对⼀个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在⼀定数量的并发访问下重复进行。
- http_load (Excellent for latency tests) ：程序非常小，解压后也不到100K；http_load以并行复用的方式运行，用以测试web服务器的吞吐量与负载。
- 阿里云性能测试（Performance Testing）：⼀个SaaS性能测试平台，具有强大的分布式压测能力，可模拟海量用户真实的业务场景，
- Tsung：⼀个开源的支持多协议的分布式压力测试工具
  - 目前支持HTTP分布式压力测试、WebDAV分布式压力测试、SOAP分布式压力测试、PostgreSQL分布式压力测试、MySQL分布式压力测试、LDAP分布式压力测试、MQTT分布式压力测试、Jabber/XMPP servers分布式压力测试
- JMeter：⼀款广为流传的开源分布式压测产品，能自动⽣成图形报告。
  - 最初被设计用于Web应用测试，如今 JMeter可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、 FTP服务器等等，还能对服务器、网络或对象模拟巨⼤的负载，通过不同压力类别测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能测试和回归测试。

#### 13.3.5 影响基准数据的因素

地理位置、网络问题、响应大小、代码处理、浏览器的行为、Web服务器配置

#### 13.3.6 问题

⼈造测试不能发现所有性能瓶颈。

- 场景及页面选择:很难重复真实⽤户的导航模式; 
- 浏览器缓存:用户缓存不同，性能差别很大;
- 中介设施:中间代理和缓存对性能影响很大;
- 硬件多样化:不同的 CPU、GPU 和内存比比皆是;
- 浏览器多样化:各种浏览器版本，有新有旧;
- 上网方式:真实连接的带宽和延迟可能不断变化。

#### 13.3.7 性能监控指标

- FP（全称“First Paint”， “首次绘制”） ：对于应用页面，首次出现视觉上不同于跳转之前内容的时间点，或者说是页面发生第⼀次绘制的时间点。

- FCP（全称“First Contentful Paint”， “首次内容绘制”）：指浏览器完成渲染DOM中第⼀部分内 容（可能是文本、图像或其他任何元素）的时间点，此时用户应该在视觉上有直观的感受。

  - 注意：只有首次绘制文本、图片（包含背景图）、非白色的canvas或SVG时才被算作FCP。

  >FP与FCP这两个指标之间的主要区别是：
  >
  >    -  FP是当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这⼀刻，这个时间点，叫做FP。
  >    -  相比之下，FCP指的是浏览器首次绘制来自DOM的内容。例如：文本，图片，SVG，canvas 元素等，这个时间点叫FCP。
  >    -  FP和FCP可能是相同的时间，也可能是先FP后FCP。

- FMP（全称“First Meaningful Paint”，翻译为“首次有意义绘制”）：指页面关键元素的渲染时间。

  - 没有标准化定义，因为关键元素可以由开发者自行定义。
  - FMP本质上是通过⼀个算法来猜测某个时间点可能是FMP，所以有时候不准。

- 首屏时间：进⼊页面之后，应用渲染完成整个⼿机屏幕（未滚动之前） 内容的时间。
  - 业界对于这个指标没有确切定论，比如是否包含屏幕内图片的渲染完成时间。

- 用户可交互时间：用户可以与应用进行交互的时间。
  - ⼀般来说，是DOMReady的时间，因为通常会在这时绑定事件操作。
  - 如果页面中涉及交互的脚步没有下载完成，那么当然没有到达所谓的用户可交互时间。
- 总下载时间：页面所有资源加载完成所需要的时间。
  - ⼀般可以统计window.onload时间，这样可以统计出同步加载的资源全部加载完的耗时。
  - 如果页面中存在较多的异步渲染，那么可以将异步渲染全部完成的 时间做为总下载时间。

- 自定义指标：由于应用特点不同，可以根据需求自定义时间。
  - 比如，⼀个类似Instagram的页面由图片瀑布流组成，那么可能非常关心屏幕中第⼀排图片渲染完成的时间。

#### 13.3.8 Performance API

- Performance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的⼀部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API。
- 该类型的对象可以通过调用只读属性 Window.performance 来获得。
- 功能强大，但并不适用于所有场景。
  - 比如，如果在单页应用中改变URL但不刷新页面（单页应用的典型路由方案），那么使用window.performance.timing所获取的数据是不会更新的，还需要开发者重新设计统计方案。同时， window.performance.timing可能无法满足⼀些自定义的数据。

#### 13.3.9 分析工具

- 基于网页分析工具
  - Web PageTest；PingDom Tools；GTmetrix；Google PageSpeed；whatsmydns
- 基于浏览器分析工具
  - Chrome自带工具F12；Firefox插件：YSlow（Yahoo工具）；Page Speed（google）

### 13.4 浏览器优化

可行的优化手段会因浏览器而异，但从核心优化策略来说，可以宽泛地分为两类：

- 基于文档的优化：熟悉网络协议，了解文档、CSS 和 JavaScript 解析管道， 发现和优先安排关键网络资源，尽早分派请求并取得页面，使其尽快达到可交互的状态。主要方法是优先获取资源、提前解析等。
- 推测性优化：浏览器可以学习用户的导航模式，执行推测性优化，尝试预测用户的下⼀次操作。然后，预先解析DNS、预先连接可能的目标。

#### 13.4.1 大多数浏览器利用的四种技术

好消息是，所有这些优化都由浏览器替我们自动完成，经常可以节省几百 ms 的网络延迟。既然如此，那理解这些优化背后的原理就至关重要了，这样才能利用浏览器的这些特性，提升应用性能。大多数浏览器都利用了如下四种技术。

- 资源预取和排定优先次序：
  - 文档、CSS 和 JavaScript 解析器可以与网络协议层沟通，声明每种资源的优先级:初始渲染必需的阻塞资源具有最高优先级，而低优先级的请求可能会被临时保存在队列中。
-  DNS预解析：
  - 对可能的域名进行提前解析，避免将来 HTTP 请求时的 DNS 延迟。预解析可以通过学习导航历史、用户的鼠标悬停，或其他页面信号来触发。
- TCP欲连接：
  - DNS 解析之后，浏览器可以根据预测的 HTTP 请求，推测性地打开 TCP 连接。 如果猜对的话，则可以节省⼀次完整的往返(TCP 握手)时间。
- 页面预渲染：
  - 某些浏览器可以让我们提示下⼀个可能的目标，从而在隐藏的标签页中预先渲染整个页面。这样，当用户真的触发导航时，就能立即切换过来。

#### 13.4.2 推测优化

- 预解析特定的域名

  ```html
  <link rel="dns-prefetch" href="//hostname_to_resolve.com">
  ```

- 预取得页面后面要用到的关键性资源

  ```html
  <link rel=“subresource" href="/javascript/myapp.js">
  ```

- 预取得将来导航要用的资源

  ```html
  <link rel=“prefetch" href="/images/big.jpeg">
  ```

- 根据对用户下⼀个目标的预测，预渲染特定页面

  ```html
  <link rel="prerender"href="//example.org/next_page.html"> 
  ```

![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115123106.png)

### 13.5 最佳实践

两个准则：

- 消除或减少不必要的网络延迟
- 将需要传输的数据压缩至最少

#### 13.5.1 性能准则

- 减少DNS查找
  - 每⼀次主机名解析都需要⼀次网络往返,从而增加请求的延迟时间,同时还会阻塞后续请求。
- 重用TCP连接
  - 尽可能使用持久连接,以消除 TCP 握手和慢启动延迟。
- 减少HTTP重定向
  - HTTP 重定向极费时间,特别是不同域名之间的重定向,更加费时;这里面既有额外的 DNS 查询、TCP 握手,还有其他延迟。最佳的重定向次数为零。
- 使⽤CDN(内容分发网络)
  -  把数据放到离用户地理位置更近的地方,可以显著减少每次 TCP 连接的网络延迟,增大吞吐量。这⼀条既适用于静态内容,也适用于动态内容。
- 去掉不必要的资源
  - 任何请求都不如没有请求快。

- 在客户端缓存资源

  - 应该缓存应用资源,从而避免每次请求都发送相同的内容。

  ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115123831.png)

- 传输压缩过的内容

  - 传输前应该压缩应用资源,把要传输的字节减至最少:确保对每种要传输的资源，采用最好的压缩手段。

  ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115123853.png)

- 消除不必要的请求开销

  - 减少请求的 HTTP 首部数据(比如 HTTP cookie),节省的时间相当于几次往返的延迟时间。

  ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115123928.png)

- 并行处理请求和响应

  - 请求和响应的排队都会导致延迟,无论是客户端还是服务器端。这⼀点经常被忽视,但却会无谓地导致很长延迟。

  ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115124006.png)

- 针对协议版本采取优化措施

  - HTTP 1.x 支持有限的并行机制,要求打包资源、跨域分散资源,等等。相对而言,HTTP 2.0 只要建立⼀个连接就能实现最优性能,同时无需针对 HTTP 1.x 的 那些优化方法。

| ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115124304.png) | ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115124327.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115124350.png) | ![image-20230115124405793](C:\Users\94327\AppData\Roaming\Typora\typora-user-images\image-20230115124405793.png) |

#### 13.5.2 指标

- 网页级指标(Page-level Metrics)
  - 这些是为整个页面捕获并显示的顶级度量值。
- 整页加载时间(Load Time)
  - 测量的时间是从初始化请求，到开始执行window.onload事件。
- 页面所有元素加载时间(Fully Loaded)
  - 从初始化请求，到Document Complete后，2秒内（中间几百毫秒轮询）没有网络活动的时间，但这2秒是不包括在测量中的，所以会出现两个差值大于或小于2秒。

- 第⼀个字节加载时间(First Byte)
  - 第⼀个字节时间（通常缩写为TTFB）被测量为从初始化请求，到服务器响应的第⼀个字节，被浏览器接收的时间（不包括DNS查询、TCP连接的时间）。
- 页面渲染时间(Start Render)
  - 测量的时间是从初始化请求，到第⼀个内容被绘制到浏览器显示的时间。在瀑布图中有两个参数指标Start Render和 msFirstPaint。
    - Start Render是通过捕获页面加载的视频，并在浏览器第⼀次显示除空白页之外的其他内容时查看每个帧来衡量的。它只能在实验室测量，通常是最准确的测量。
    - msFirstPaint（IE专⽤属性）是由浏览器本身报告的⼀个测量，它认为绘制的第⼀个内容。通常是相当准确，但有时它报告的时候，浏览器只画⼀个空白屏幕。
- 首屏展现平均值(Speed Index)
  - 表示页面呈现用户可见内容的速度（越低越好）。有关如何计算的更多信息，请参见：Speed Index。
- DOM元素数量(DOM Elements)
  - 在测试结束时测试页面上的DOM元素的计数。
- 请求级度量标准(Request-level Metrics)
  - 这些是为每个请求捕获和显示的度量。

### 13.6 网飞网络性能案例研究

- 改善Netflix.com在桌⾯的交互时间

- 通过改进 Netflix.com 注册过程中所使用的 JavaScript 及预加载技术， 开发团队能够为移动用户和桌面用户提供更好的用户体验，主要改进如下。

  - 加载和交互时间减少了 50%（Netflix.com 桌面登录主页）；
  - 在从 React 和其他客户端库切换到普通的 JavaScript 之后， JavaScript 包大小减少了 200KB。服务器端仍然使用 React。

  - HTML、CSS、JavaScript（React）预加载使后续页面的浏览交互时间减少了 30%。

#### 13.6.1 减少 JavaScript 传输，缩短交互时间

- Netflix 针对其登录主页的性能进行了优化
  - 这个页面最初包含 300KB 的 JavaScript，其中⼀些是 React 和其 他客户端代码（比如像 Lodash 这样的实用程序库），还有⼀些是补充 React 状态所需的上下文数据。
- 使用 Chrome 的开发⼯具和 Lighthouse 模拟在 3G 连接上加载登录主页，结果显示，登录主页需要 7 秒的加载时间，对于⼀个简单的登录页面来说太长了，因此需要研究改进的可能。通过⼀些性能审计， Netflix 发现他们客户端的 JS 开销很高。
- 登录主页是否真得需要 React？
  - 用Vanilla JavaScript 替换！！！

#### 13.6.2 优化

移植到原生 JavaScript 的组件列表：

- 基础交互（主页选项卡）
- 语言切换器
- “Cookie 横幅（Cookie banner）”（针对非美国用户）
- 客户端日志分析
- 性能度量和记录
- 广告归属检测引导代码（出于安全考虑，放在沙箱式 iFrame 中）

#### 13.6.3 结果

尽管 React 最初占用的空间仅为 45KB，但将 React、几个库和相应的应用程序代码从客户端移除后，JavaScript 的总量减少了 200KB 以 上，这使得 Netflix 在登录主页的交互时间减少了 50% 以上。

![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115125503.png)

#### 13.6.4 后续页面的 React 预加载

预加载

- 通过浏览器内置的 API 和 XHR 预加载 
- 交互时间减少了 30%

![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115125612.png)

### 13.7 Robots.txt

- “网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。
  - 源自1994 
  - https://www.robotstxt.org/robotstxt.html
- Robots协议是国际互联网界通行的道德规范，基于以下原则建立：
  - 搜索技术应服务于人类，同时尊重信息提供者的意愿，并维护其隐私权；
  - 网站有义务保护其使用者的个人信息和隐私不被侵犯。
- robots是⼀个协议。robots.txt文件是⼀个文本文件，放置在网站根目录下。

- 任何机器人都不应该访问任何以“/yoursite/temp/”开头的 URL，除了名为“IxeBot”的机器⼈

  ```
  User-agent: *
  Disallow: /yoursite/temp/
  
  User-agent: IxeBot
  Disallow:
  ```

### 13.8 总结

- 密切关注 JavaScript 的开销

- Netflix 的折中方案是，使用 React 在服务器端渲染登录页面，但同时也为注册过程的其他部分预取 React 代码。这不仅优化了首次加载性能，还优化了注册过程其余部分的加载时间，因为它是单页应用，所以有更大的 JS 包需要下载。

- 补充：

  ![](https://cdn.jsdelivr.net/gh/ukrys/web-frontend-images/20230115130247.png)

  